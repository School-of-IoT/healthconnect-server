require("dotenv").config();

const patientModel = require("../../models/patientModel");
const secret = process.env.CRYPTO_SECRET;
const crypto = require("crypto").createHmac;

// AdminView
const viewAdmin =  async (req, res) => {
    const patient = await patientModel.find();
    if (!patient){
        return res.json ({message: "Not Avalaible"});
    }
    return res.json({patient});
}; 


const fetchPatientData_ID = async (req, res) => {
    try{
        const { _id } = req.params;
        const patient = await patientModel.findById(_id);
        if (!patient){
            return res.json ({message: "invalid ID"});
        }
        return res.json ({ patient });
    }
    catch(error){
        return res.status(500).json({error: error.message});
    }    
};


const getGeoAPI = async (req, res) => {
    try{
        const { user } = req.params;
        const patient = await patientModel.find({user: user});
        if (!patient){
            return res.json ({message: "invalid user"});
        }
        let api = process.env.GEO_API;
        return res.json ({geo_api: api});
    }
    catch(error){
        return res.status(500).json({error: error.message});
    }   
};


// GET
// route: /login
// description: To get JIT token with 'user' & 'pass'
// q-parameter: username and password
const login = async (req, res) => {
    try {
        const body = req.query;
        const pass = body.pass;
        const user = body.user;
        const patient_pass = await crypto("sha256", secret).update(pass).digest("hex");
        const patient = await patientModel.find({user: user, pass: patient_pass});
        const check = (patient == []);
      
        if (!check){    
            const valpass = patient[0].pass;
            const valuser = patient[0].user;   
            
            if ((valpass == patient_pass) && (valuser == user)){
                const uid = patient[0]._id;
                //JIT(Just-in-time) handler
                var date_ob = new Date();
                var moment = date_ob.getDate()+'-'+date_ob.getMonth()+'/'+date_ob.getHours();
                const token = process.env.CRYPTO_TOKEN + moment;
                const auth_token = await crypto("sha256", token).update(valpass).digest("hex");
                return res.json({token: auth_token});
            }
            else{
                return res.status(500).json({error: error.message});
            }
        }   
        else{
            return res.status(500).json({error: error.message});
        }    
        return res.json (patient);
    } 
    catch(error) {
        return res.status(500).json({error: error.message});
    }
};



// GET
// route: /data
// description: To get patient data with 'user' & 'token'
// q-parameter: user & token (generated by respose during login)
const data = async (req, res) => {
    
    try{
        const body = req.query;
        const user = body.user;
        const ch_token = body.token;
        const patient = await patientModel.find({user: user});
        
        if (!patient){
            return res.status(500).json ({message: "No Data Found"});
        }
        else{
            const valpass = patient[0].pass;
            //JIT(Just-in-time) handler
            var date_ob = new Date();
            var moment = date_ob.getDate()+'-'+date_ob.getMonth()+'/'+date_ob.getHours();
            const token = process.env.CRYPTO_TOKEN + moment;
            const auth_token = await crypto("sha256", token).update(valpass).digest("hex");
          
            if (auth_token == ch_token)
            {
              return res.json ({ patient });
            }
            else{
              return res.status(500).json ({message: "Token does not match. Try to Login Again."});
            }
        }    
    }
    catch(error){
        return res.status(500).json({error: error.message});
    }    
};




// POST
// route: /patient/signup
// description: To add new patient
// request body: patient object
// v1Route.post("/patient/signup",
const signup = async(req, res) => {

    try {
        var { newpatient } = req.body;

        // Ensure name, user, and pass are provided
        if (!newpatient || !newpatient.name || !newpatient.user || !newpatient.pass) {
            return res.status(400).json({ error: "Missing required fields: name, username, and password" });
        }

        const pass = newpatient.pass;
        const user = newpatient.user;
        const username_check = await patientModel.find({ user: user });
        
        if (!(username_check[0] === undefined)) {
            return res.status(400).json({ error: "Username already exists" });
        }
      
        const patient_pass = await crypto("sha256", secret).update(pass).digest("hex");
        await patientModel.create(newpatient);
        const filter = { user: user };
        const update = { pass: patient_pass };

        let doc = await patientModel.findOneAndUpdate(filter, update, {
            new: true
        });

        const { _id } = doc;
        return res.json({ message: "Patient Created", uid: _id });
    } 
    catch(error) {
        return res.status(500).json({ error: error.message });
    }
};



// PUT
// route: /patient/update/:_id
// description: To update a patient
// e-parameter: _id 
// request body: patient object
const updatePatientData = async (req, res) => {

    try {
        const { _id } = req.params;
        const { patientData } = req.body;
        const updatepatient = await patientModel.findByIdAndUpdate(
            _id,
            { $set: patientData},
            { new: true}     
        );
        return res.json({ message: "Patient Data updated!" });
    }
    catch(error){
        return res.status(500).json({error: error.message});
    }
       
};



// DELETE
// route: /patient/delete/:_id
// description: To delete a patient
const deletePatientData = async (req, res) => {
    try{
        const { _id } = req.params;
        await patientModel.findByIdAndDelete(_id);
        return res.json({message: "Patient Deleted ðŸ”ª"});
    }
    catch(error){
        return res.status(500).json({error: error.message});
    }
    
};


module.exports = {viewAdmin,fetchPatientData_ID, getGeoAPI, login, signup, data, updatePatientData, deletePatientData}